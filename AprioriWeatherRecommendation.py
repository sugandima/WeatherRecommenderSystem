# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J4_usKUQKjAIHlGGC8hfE0RF5cvYO0y2
"""

import numpy as np
import pandas as pd
from mlxtend.frequent_patterns import apriori, association_rules



data = pd.read_excel('WeatherData.xls')
data.head()

data.columns

#data_MinTemp = data['MIN']
#data_MinTemp

year_weather_min = data.groupby(['MIN'])['YEARMODA'].count().reset_index(name ='NumRecords')
year_weather_min

#data_MaxTemp = data['MAX']
#data_MaxTemp

year_weather_max = data.groupby(['MAX'])['YEARMODA'].count().reset_index(name ='NumRecords1')
year_weather_max

#data_PRCP= data['PRCP']
#data_PCRP

year_weather_prcp = data.groupby(['PRCP'])['YEARMODA'].count().reset_index(name ='NumRecords2')
year_weather_prcp

#order the data set in descending Number of records order

year_weather_min_order = year_weather_min.sort_values(['NumRecords'],ascending=False)
year_weather_min_order

year_weather_max_order = year_weather_max.sort_values(['NumRecords1'],ascending=False)
year_weather_max_order

year_weather_prcp_order = year_weather_prcp.sort_values(['NumRecords2'],ascending=False)
year_weather_prcp_order

#create our data subset containing the weather by year
weather_2010 = data[data['YEARMODA'] ==2010].reset_index()
weather_2010.head(5)

weather_2011 = data[data['YEARMODA'] ==2011].reset_index()
weather_2011.head(5)

#consolidate the whether conditions into 1 (year) per row with each product 1 hot encoded (seems not correct yet)
weather_set = (data[data['YEARMODA'] ==2010]
          .groupby(['MIN', 'YEARMODA'])
          .sum().unstack().reset_index().fillna(0)
          .set_index('MIN'))

weather_set

#working one(without rounding MIN values due to memory insufficient problem)
weather_set = (data[data['PRCP'] != '0.00G']
          .groupby(['YEARMODA', 'MIN'])
          .sum().unstack().reset_index().fillna(0)
          .set_index('YEARMODA'))

weather_set

weather_set.columns


#Recode the numbers in the cells to indicate if weather condition was affected (1) or not (0). The actual number is not important
def encode_units(x):
    if x <= 0:
        return 0
    if x >= 1:
        return 1

weather_set1 = weather_set.applymap(encode_units)
weather_set1 

#create frequent weather sets and association rules

from mlxtend.frequent_patterns import apriori
from mlxtend.frequent_patterns import association_rules

frequent_weathersets = apriori(weather_set1, min_support=0.0045, use_colnames=True)
frequent_weathersets